\chapter{Biblioteka:  RIT}
\label{app:takeMeHome}
\thispagestyle{appendixStyle}

Poniżej opisana biblioteka \textsc{RIT} (ang. \textit{Recoverable Incremental Tree}) stanowi zwieńczenie naszej pracy --- zawiera implementacje wszystkich algorytmów, których pseudokody pojawiły się w powyższym tekście, zarówno tych klasycznych, imperatywnych, jak i dotyczących problemów programowania liniowego, bądź całkowitoliczbowego. Całość biblioteki została napisana w języku \textsc{C++} w jego najnowszym, dostępnym na chwilę powstawania tego dokumentu, standardzie \textsc{C++14}, z wykorzystaniem elementów bibliotek stron trzecich, takich jak: \textsc{graphviz}, \textsc{gtest} oraz \textsc{log4cxx}. Poniższy rozdział zawiera skrócony opis jej funkcjonalności\footnote{Pełen projekt wraz z jego dokumentacją został umieszczony na zdalnym repozytorium pod adresem: \url{https://github.com/PWrGitHub194238/RIT}.}, sposób instalacji oraz korzystania z niej, także w podstawowym zakresie.

\section{Wymagania i instalacja}

Całość omawianej biblioteki została zaimplementowana w środowisku systemu \textsc{Ubuntu 15.10} dla architektury $64$-bitowej, w związku z tym wszelkie przykłady oraz wykorzystywane skrypty zostały napisane z myślą o użytkownikach systemu z tej rodziny --- proces kompilacji oraz instalacji biblioteki może się różnić w zależności od wykorzystywanego systemu operacyjnego. Dodatkowo jeden z prezentowanych skryptów korzysta z konsolowego \textsc{api} programu \textsc{Eclipse Mars.1 (4.5.1)}, przystosowanego do pisania e językach \textsc{C} oraz \textsc{C++} (\textsc{Eclipse CDT}), który posłużył do napisania całości biblioteki, co tym samym czyni go preferowanym narzędziem w przypadku chęci budowy biblioteki \textsc{RIT} na podstawie jej, udostępnionych na zdalnym repozytorium, źródeł. Poniżej prezentowany proces ma w tym pomóc. 

\subsection{Struktura projektu}

Prezentowane drzewo katalogów ilustruje strukturę projektu oraz precyzuje położenie wszystkich, istotnych z punktu widzenia instalacji, skryptów. Nim przejdziemy do budowy biblioteki \textsc{RIT} ze źródeł, zapoznamy się ze wszystkimi ważniejszymi częściami składowymi projektów: \textsc{RIT}, \textsc{RIT\_Library} oraz \textsc{RIT\_Examples}.

\small
\noindent\makebox[\textwidth][c]{%
\begin{minipage}{.3\textwidth}
\dirtree{%
	.1 /.
	.2 \textsf{\textcolor{lgray}{EmptyTeX}}.
	.2 \textsf{\textcolor{lgray}{Presentations}}.
	.2 \textsf{\textcolor{lgray}{References}}.
	.2 \textsf{RIT\_Examples}.
	.3 \textsf{include}.
	.3 \textsf{lib}.
	.3 \textsf{src}.
	.3 \textsf{\textcolor{lgray}{test}}.
	.3 build.bash.
	.3 clean.bash.
	.3 config.bash.
	.3 fullBuild.bash.
	.3 \textcolor{lgray}{Log4cxxConfig.xml}.
	.3 memcheck.bash.
	.3 \textcolor{lgray}{RIT\_Examples.Doxyfile}.
}
\end{minipage}% This must go next to `\end{minipage}`
\begin{minipage}{.3\textwidth}
\dirtree{%
	.1 /.
	.2 \textsf{RIT\_Examples}.
	.3 \textcolor{lgray}{RIT\_Examples\_bac}.
	.3 \textcolor{lgray}{valgrind.supp}.
	.2 \textsf{RIT\_Library}.
	.3 \textsf{src}.
	.3 build.bash.
	.3 clean.bash.
	.3 config.bash.
	.3 fullBuild.bash.
	.3 \textcolor{lgray}{Log4cxxConfig.xml}.
	.3 memcheck.bash.
	.3 \textcolor{lgray}{RIT\_Library.Doxyfile}.
	.3 \textcolor{lgray}{RIT\_Library\_bac}.
	.3 toogleLogs.bash.
	.3 \textcolor{lgray}{valgrind.supp}.
}
\end{minipage}% This must go next to `\end{minipage}`
\begin{minipage}{.3\textwidth}
\dirtree{%
	.1 /.
	.2 \textsf{Scripts}.
	.3 \textsf{\textcolor{lgray}{octave}}.
	.3 \textsf{\textcolor{lgray}{plots}}.
	.3 \textcolor{lgray}{cleanThesis.bash}.
	.3 \textcolor{lgray}{generatePlot.bash}.
	.3 \textcolor{lgray}{randDistance.bash}.
	.3 \textcolor{lgray}{randDistance.pl}.
	.2 \textsf{\textcolor{lgray}{Thesis}}.
	.3 \textsf{\textcolor{lgray}{Documentation}}.
	.3 \textcolor{lgray}{Thesis.pdf}.
	.2 buildProject.bash.
	.2 clean.bash. 
	.2 \textcolor{lgray}{LICENSE}. 
	.2 \textcolor{lgray}{README.md}. 
	.2 RIT\_bac.
}
\end{minipage}}

Zaprezentowana powyżej struktura przedstawia wszystkie główne komponenty projektu, łącznie ze skryptami czy folderami, które nie będą na razie dla nas istotne (zostały one zaznaczone szarym kolorem w celu lepszej przejrzystości przedstawianej struktury katalogów). Etap budowania oraz uruchamiania aplikacji jest mocno zautomatyzowany, dlatego też podczas wykonywania wszelkich czynności będziemy głównie korzystać z plików napisanych dla jednej z najbardziej popularnych powłok systemowych --- skryptów o rozszerzeniu \textsf{*.bash}. Omówimy teraz przeznaczenie każdego z nich w folderach: \textsf{RIT\_Library} oraz  \textsf{RIT\_Examples}, jako że w znacznym stopniu pokrywają się one ze sobą (są przeznaczone dla dwóch różnych podprojektów, z czego sposób budowy każdego z nich jest bardzo podobny).

\dirtree{%
	.1 /.
	.2 \textsf{RIT\_Library} / \textsf{RIT\_Examples}.
	.3 config.bash.
}

Główny skrypt dla projektów \textsc{RIT\_Library} oraz \textsc{RIT\_Examples}. Po wywołaniu wiersza poleceń ( \texttt{CRTL + ALT + T}) i wykonaniu polecenia \mintinline{bash}|./config.bash| (lub \mintinline{bash}|bash config.bash| w przypadku, gdy plik skryptu nie posiada atrybutu, określającego go jako plik wykonywalny), ukażą nam się następujące opcje do wyboru:

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{text}
|# :\textapprox/git/RIT/RIT\_Library\$ ./config.bash|
You have to specify at least one action from these:
	autocompletion
	help
	install
	initBuild
\end{minted}

Wybierając pierwszą z nich (wpisując w terminalu \mintinline{bash}|./config.bash autocompletion| i zatwierdzając swój wybór), zostaniemy poproszeni o zezwolenie na podwyższenie uprawnień uruchomionego procesu --- w przypadku wyrażenia zgody, do katalogu systemowego \textsf{"/etc/bash\_completion.d/} zostanie przeniesiony plik \textsf{RIT\_Library\_bac} (bądź \textsf{RIT\_Examples\_bac}), który umożliwi systemowi operacyjnemu podpowiadanie nam składni wszystkich przyszłych komend (zasugeruje nam także możliwe ich parametry). Aby zmiany wprowadzone przez skrypt były widoczne, wymagane jest ponowne uruchomienie wiersza poleceń (\texttt{CRTL + ALT + T}). Od tej chwili możemy, poprzez podwójne naciśnięcie klawisza \texttt{TAB}, wypisać wszystkie, możliwe do zastosowania w danej chwili (na podstawie do tej pory wpisanego ciągu znaków w wierszu poleceń), parametry. Dodatkowo, jeżeli argument określonego parametru powinien spełniać określone właściwości (np. być plikiem wykonywalnym), po naciśnięciu klawisza \texttt{TAB} automatycznie zostanie podpowiedziana jego wartość (jeśli jest tylko jedna możliwa):

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize,]{text}
|# :\textapprox/git/RIT/RIT\_Library\$ ./config.bash autocompletion|
In order to successfully execute this commamd, extra privileges will be needed:
	[sudo] [...]
You have granted this script root privileges.
Please, restart shell in order to changes take effect.
\end{minted}

Oczywiście uruchomienie skryptu z, następnym w kolejności, parametrem \mintinline{bash}|help|, spowoduje wypisanie opisu wszystkich możliwych do zastosowania w nim parametrów wraz z pełnym wyrażeniem, opisującym sposób jego wywołania. Następna z możliwych opcji dla omawianego skryptu (\mintinline{bash}|install|) pozwala użytkownikowi na przeprowadzenie instalacji komponentów, wymaganych do poprawnego działania biblioteki. Poniżej zaprezentowano rozszerzony opis parametrów, które użytkownik może podać, w celu sprecyzowania zachowania uruchamianego polecenia, a które zostaną podpowiedziane:
\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{text}
|# :\textapprox/git/RIT/RIT\_Library\$ ./config.bash install|
-d|--defaults - wszystkie parametry, o które pyta skrypt w trakcie wykonywania 
		są uzupełniane wartościami domyślnymi, a sam proces 
		nie jest przerywany zapytaniami o ich podanie,
-f|--force-yes - skrypt podczas instalacji odwołuje się do swoich, 
		podwyższonych na czas jego działania, uprawnień, 
		gdzie niepodanie tej flagi skutkowałoby pojawianiem się próśb 
		o podjęcie decyzji. W przypadku zastosowania tej flagi, 
		domyślnymi odpowiedziami są odpowiedzi twierdzące/przyzwalające.
--rapidjson-path <arg> - ścieżka kalagou, do którego zostaną pobrane pliki 
		dla wymaganego w aplikacji komponentu rapidJSON.
--rapidjson-include-path <arg> - ścieżka katalogu, do którego zostaną przeniesione 
		pliki nagłówkowe wymaganego komponentu rapidJSON,
\end{minted}
gdzie argumentami ostatnich dwóch parametrów mogą być zarówno ścieżki względne jak i bezwzględne. W czasie całego procesu zostaniemy kilkakrotnie zapytani o przyzwolenie na pobranie oprogramowania, w oparciu o które skrypt przeprowadzi automatyczną  instalację następujących elementów: \textsc{liblog4cxx10v5}, \textsc{liblog4cxx10-dev}, \textsc{graphviz}, \textsc{graphviz-dev}, \textsc{RapidJSON}. W przypadku braku większej liczby komponentów, skrypt poprosi o przyzwolenie na instalację następujących elementów: \textsc{git} oraz \textsc{libpthread-stubs0-dev}. Jeżeli dane oprogramowanie jest już przez nas posiadane, zostanie pominięte jego pobieranie oraz instalacja:

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{text}
|# :\textapprox/git/RIT/RIT\_Library\$ ./config.bash install|
In order to successfully install all dependencies,
apt-get will be called, extra privileges will be needed:
	[sudo] [...]
You have granted this script root privileges.
Following dependencies will be installed:
	liblog4cxx10v5
	liblog4cxx10-dev
	graphviz
	graphviz-dev
	RapidJSON.
Confirm installation of this packages? (y/n): [y]
Installing 'Log4cxx' library...
	[...]
Confirm installation of package "liblog4cxx10v5"? [y]
	[...]
Confirm installation of package "liblog4cxx10-dev"? [y]
	[...]
Installing 'GraphViz' library...
	[...]
Installing 'RapidJSON' library...
Enter where to checkout RapidJSON project ("~/git/RIT/RIT_Library/RapidJSON/" if left blank):
Enter where to move RapidJSON header files ("/usr/local/include/rapidjson/" if left blank): 
"git" is required to checkout GTest project's sources.
Confirm installation of package "git"? [y]
	[...]
"pthread" library will be needed to build GTest form sources.
Confirm installation of package "libpthread-stubs0-dev"? [y]
	[...]
Checking out the RapidJSON project...
	[...]
RapidJSON project has been saved into "~/git/RIT/RIT_Library/RapidJSON/.
	[...]
RapidJSON header files have been moved to "/usr/local/include/rapidjson/".
Delete RapidJSON project sources? (y/n): [y]

Package 'liblog4cxx10v5' is already installed. Skipping...
\end{minted}

Po zakończeniu się powyższego procesu, projekt, dla którego uruchamialiśmy powyższy skrypt (\textsc{RIT\_Library} --- przebieg instalacji dla \textsc{RIT\_Examples} jest bliźniaczo podobny i nie będziemy go osobno prezentować\footnote{Dla projektu \textsc{RIT\_Examples} dodatkową zależnością jest biblioteka \textsc{gTest}, służąca do przeprowadzania automatycznych testów biblioteki \textsc{RIT\_Library} zawartych w tym projekcie. Zależności projektu możemy pobrać chociażby wykonując polecenie \mintinline{bash}|./config.bash install -d -f| (z poziomu katalogu \textsc{RIT\_Examples}).}), jest już gotowy do bycia zbudowanym ze źródeł zawartych w katalogach \textsf{./src/src/} oraz \textsf{./src/include/}. Następnym krokiem, po pobraniu i instalacji wszelkich wymaganych przez bibliotekę zależności, w celu budowy aplikacji, jest wywołanie skryptu \mintinline{bash}|config.bash| z parametrem \mintinline{bash}|initBuild| --- w tym przypadku skrypt zostanie poproszony o wygenerowanie, w odpowiednich katalogach, plików zawierających zbiory reguł, dotyczących procesu budowania aplikacji (biblioteki bądź przykładowego programu, który ją wykorzystuje):

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{text}
|# :\textapprox/git/RIT/RIT\_Library\$ ./config.bash initBuild --path \textapprox/workspace|
WARNING: In order to Eclipse successfully generate project's makefiles, 
You have to run this script as Eclipse's owner.
Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=256m; support was removed in 8.0
	[...]
20:51:35 **** Clean-only build of configuration Debug for project RIT_Library ****
	[...],
\end{minted}
gdzie argumentem parametru \mintinline{bash}|--path| jest ścieżka do katalogu roboczego programu \textsc{Eclipse}\footnote{Celem skryptu jest uruchomienie wspomnianej aplikacji w trybie cichym (bez pokazywania jej graficznego interfejsu) i rozpoczęcie procesu kompilacji dla wskazanych w skrypcie projektu, dla wszystkich profili dostępnych w jego ustawieniach (domyślnie: \textsf{Debug}, \textsf{Release}, \textsf{Shared}, \textsf{Static}). Operacja ta ma głównie na celu wymuszenie automatycznego wygenerowania plików \textsf{makefile}, zawierających reguły budowania projektu, z których następnie będą korzystać pozostałe skrypty --- już bez odwoływania się do zewnętrznego programu. Aby zatem z powodzeniem wywołać opisywany skrypt, zakładamy, że przedstawiane w tym rozdziale projekty (\textsc{RIT\_Library}, \textsc{RIT\_Examples}) są bezpośrednio klonowane z repozytorium za pośrednictwem wspomnianej aplikacji (w takim wypadku program \textsc{Eclipse} sam zainicjalizuje w swoim katalogu roboczym oba projekty).} W przypadku poprawnego zakończenia się uruchomionego skryptu, następujące katalogi zostaną wygenerowane w jednej z możliwych lokalizacji (wraz ze skompilowanymi do pliku wykonywalnego/biblioteki współdzielonej/statycznej projektami).

\small
\noindent\makebox[\textwidth][l]{%
	\begin{minipage}{.2\textwidth}
		\dirtree{%
			.1 /.
			.2 \textsf{RIT\_Library}.
			.3 \textsf{Debug}.
			.4 makefile.
			.4 RIT\_Library.
			.3 \textsf{Release}.
			.4 makefile.
			.4 libRIT\_Library.
		}
	\end{minipage}% This must go next to `\end{minipage}`
	\begin{minipage}{.3\textwidth}
		\dirtree{%
			.1 /.
			.2 \textsf{RIT\_Library}.
			.3 \textsf{Shared}.
			.4 makefile.
			.4 libRIT\_Library.so.
			.3 \textsf{Static}.
			.4 makefile.
			.4 libRIT\_Library.a.
		}
	\end{minipage}% This must go next to `\end{minipage}`
	\begin{minipage}{.2\textwidth}
		\dirtree{%
			.1 /.
			.2 \textsf{RIT\_Examples}.
			.3 \textsf{Debug}.
			.4 makefile.
			.4 RIT\_Examples.
			.3 \textsf{Release}.
			.4 makefile.
			.4 libRIT\_Examples.
		}
	\end{minipage}% This must go next to `\end{minipage}`
	\begin{minipage}{.3\textwidth}
		\dirtree{%
			.1 /.
			.2 \textsf{RIT\_Examples}.
			.3 \textsf{Shared}.
			.4 makefile.
			.4 libRIT\_Examples.so.
			.3 \textsf{Static}.
			.4 makefile.
			.4 libRIT\_Examples.a.
		}
	\end{minipage}
}

Tak wygenerowane pliki (w szczególności \textsf{./RIT\_Library/Static/libRIT\_Library.a}) następnie będziemy chcieli przenieść, przy pomocy innego skryptu, do odpowiednich katalogów testowego projektu \textsc{./RIT\_Examples} --- główną jego częścią są testy jednostkowe, mające na celu pokryć jak największy obszar funkcjonalności biblioteki. Program w znacznej mierze jest oparty o funkcjonalność, którą udostępniają mu pliki nagłówkowe przed chwilą zbudowanej biblioteki --- procesem przeniesienia wymaganych plików z jednego projektu do drugiego zajmie się następujący skrypt:
	
\dirtree{%
	.1 /.
	.2 buildProject.bash,.
}
który, uruchomiony z parametrem \mintinline{bash}|moveFiles|, dokonuje przesunięcia statyczne biblioteki \textsf{libRIT\_Library.a} oraz odpowiadających jej plików nagłówkowych z katalogu \textsf{./RIT\_Library/src/include/} odpowiednio do \textsf{./RIT\_Examples/lib/} i \textsf{./RIT\_Examples/include/RIT}:

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{text}
|# :\textapprox/git/RIT/\$ ./buildProject.bash moveFiles|
Moving static library 'libRIT_Library.a' 
from '|\textapprox|/git/RIT/RIT_Library/libRIT_Library.a' to 'RIT_Examples/lib'.
Coping includes from 'RIT_Library/src/include' to 'RIT_Examples/include/RIT'.
Done.
\end{minted}

Po tej operacji możemy przejść do projektu \textsf{./RIT\_Examples}, a następnie skompilować go za pomocą polecenia \mintinline{bash}|./build.bash|, które umożliwia nam wybór pomiędzy kilkoma rodzajami kompilacji:

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{text}
|# :\textapprox/git/RIT/RIT\_Examples\$ ./build.bash|
all        - buduj projekt dla wszystkich możliwych konfiguracji (wymienionych poniżej),
debug      - buduj projekt wraz z dołączonymi informacjami,
             pozwalającymi na szczegółową analizę plików źródłowych projektu,
release    - buduj projekt w finalnej jego formie,
shared     - buduj projekt jako bibliotekę współdzieloną,
static     - buduj projekt jako bibliotekę statyczną,
doc        - wygeneruj tylko dostępną dla projektu dokumentację,
-f --force,
\end{minted}
gdzie ostatnia flaga wymusza ponowną kompilację całego projektu\footnote{W przypadku, gdy chcielibyśmy kilkukrotnie dokonać kompilacji jego źródeł bez nanoszenia w międzyczasie żadnych zmian, wszystkie procesy, poza pierwszym, zostaną zaniechane, chyba, że wywołamy je razem z flagą \mintinline{bash}|--force|.}. 

\subsection{Pomocnicze skrypty}

Przedstawimy teraz alternatywną ścieżkę budowy obydwu projektów wraz z pozostałymi rozwiązaniami, usprawniającymi poruszanie się pomiędzy nimi. Na początku zaznaczmy, że kroki, które opisaliśmy dla wywoływanych procesów: \mintinline{bash}|./config.bash install| oraz \mintinline{bash}|./config.bash initBuild|, są nadal konieczne, gdyż generują pliki, które gwarantują poprawne wykonywanie się następnych procedur. Przyjrzyjmy się jeszcze raz poleceniu \mintinline{bash}|./buildProject.bash|, po którego wywołaniu otrzymamy pełną listę poleceń dla niego dostępnych, których poszerzony opis umieszczony został poniżej:

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{text}
|# :\textapprox/git/RIT\$ ./buildProject.bash|
autocompletion   - podobnie jak to miało miejsce w opisanych wcześniej przykładach, 
		   wywołanie skryptu z tym parametrem spowoduje dodanie informacji 
		   o dostępnych dla tego skryptu parametrach do systemu,
buildAll         - buduje oba projekty, troszcząc się jednocześnie 
		   o wszystkie procesy, które zachodzą po drodze
buildStaticLib   - buduje tylko statyczną wersję biblioteki |\textsc{RIT\_Library}|, 
		   potrzebną do poprawnego uruchamiania drugiego z projektów,
buildExample     - kompiluje tylko aplikację testową,
clean            - porządkuje projekty, usuwając z nich 
		   wygenerowane rozwiązania  jak i pliki dzienników, 
		   przechowujących zapisy wygenerowane podczas działania aplikacji,
-l --without-log - buduje projekt z usuniętymi z niego zależnościami
		   względem zewnętrznej biblioteki |\textsc{log4cxx}|
-f --force       - wymusza przebudowanie projektów w przypadku, 
		   gdy od czasu jego ostatniej kompilacji 
		   nie zmieniły się ich źródła.
\end{minted}

Pominęliśmy tutaj jeden z parametrów, \mintinline{bash}|moveFiles|, gdyż ten opisaliśmy już wcześniej. Jak widzimy, powyższy skrypt, poza możliwością przeniesienia plików, wymaganych przez projekt \textsc{RIT\_Examples}, oferuje także możliwość bezproblemowego zbudowania każdego z projektów osobno, bądź skompilowania całości poprzez wykonanie jednego polecenia (\mintinline{bash}|./buildProject.bash buildAll|). Dodatkowo, na samym początku tego rozdziału, wspomnieliśmy o tym, że oba projekty wykorzystują elementy bibliotek zewnętrznych --- jedną z nich jest biblioteka służąca do prowadzenia dziennika zdarzeń aplikacji, \textsc{log4cxx}. Dzięki wykorzystaniu flagi \mintinline{bash}|--without-log| jesteśmy w stanie skompilować dany projekt bez tej jednej zależności (wspomnianą bibliotekę oraz jej wykorzystanie szerzej omówimy później).

Kolejność opisywania pozostałej części skryptów jest przypadkowa i nie ma dla nas znaczenia, gdyż mają one tylko charakter pomocniczy i ich uruchamianie nie jest w żaden sposób wymagane w celu przeprowadzenia, powyżej opisanego, procesu kompilacji.

\dirtree{%
	.1 /.
	.2 clean.bash.
}

Tak samo jak \textsf{./buildProject.bash}, skrypt ten bazuje na funkcjach będących częścią plików \textsf{./RIT\_Library/clean.bash} oraz \textsf{./RIT\_Examples/clean.bash} i jest dla nich alternatywą. W odróżnieniu od wymienionych, uruchomienie tego skryptu spowoduje próbę przeglądu wszystkich katalogów (nie tylko \textsf{./RIT\_Library} i \textsf{./RIT\_Examples}) w poszukiwaniu plików o rozszerzeniach, wskazujących na to, że powstały w wyniku innych operacji i można je usunąć (np. pliki powstałe przy kompilacji projektów, dzienniki aplikacji, inne pliki tymczasowe). Jeżeli w danym katalogu znajduje się już skrypt o nazwie \textsf{clean.bash}, zostanie on uruchomiony automatycznie z parametrem \mintinline{bash}|all|, w celu usunięcia wszystkich zbędnych plików z danego katalogu (możliwe jest także ręczne uruchomienie poszczególnych skryptów z jednym z parametrów: \mintinline{bash}|all|, \mintinline{bash}|debug|, \mintinline{bash}|shared|, \mintinline{bash}|static|, \mintinline{bash}|doc|).

\dirtree{%
	.1 /.
	.2 \textsf{RIT\_Library} / \textsf{RIT\_Examples}.
	.3 memcheck.bash.
}
Skrypt został napisany w celu walidacji kompilowanego rozwiązania --- testuje podany program pod kątem wycieków pamięci i, w przypadku istnienia takowych, zwraca ich liczbę oraz całkowity obszar pamięci, jaki jest tracony w wyniku uruchomienia takiego programu. Skrypt przyjmuje szereg parametrów, które opiszemy poniżej.

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{text}
|# :\textapprox/git/RIT/RIT\_Library\$ ./memcheck.bash|
-f --force-yes - działanie skryptu opiera się o funkcjonalność zewnętrznego programu 
		do dynamicznej analizy kodu |\textsc{Valgrind}|. W przypadku braku takowego oprogramowania 
		zostaniemy poproszeni o zgodę na jego instalację. Jeżeli w parametrach programu
		podamy omawianą flagę, takie powiadomienie nie wystąpi, 
		gdyż skrypt jest zmuszony do cichego (bez wchodzenia 
		w interakcję z użytkownikiem) wykonania wszystkich poleceń.
-r --runnable <arg> - ścieżka do pliku wykonywalnego, będącego wynikiem kompilacji projektu 
		napisanego w jednym z języków, które |\textsc{Valgrind}| obsługije: |\textsc{C}|, |\textsc{C++}|. 
		W przypadku podania tej opcji i wymuszenia na systemie operacyjnym 
		podpowiedzi argumentów, zostaną wypisane tylko ścieżki do tych plików, 
		które posiadają status bycia plikami wykonywalnymi (w przypadku istnienia 
		pojedynczego pliku, jego nazwa zostanie automatycznie w całości uzupełniona).
-o --output <arg> - ścieżka pliku, do którego zostaną przekierowane wszystkie komunikaty 
		wygenerowane przez program |\textsc{Valgrind}| w trakcie jego działania. Informacje, 
		wypisywane przez sam skrypt, nie są do tego pliku przekierowywane.
-s --suppressions <arg> - ścieżka do pliku zawierającego listę opisów błędów, 
		które podczas dynamicznej analizy kodu mają być ignorowane,
\end{minted}
gdyż część błędów, będąca wynikiem takiej analizy, może nie powstawać bezpośrednio z winy testowanego oprogramowania (\textsc{RIT\_Library} lub \textsc{RIT\_Examples}), a być efektem wykorzystywania bibliotek zewnętrznych\footnote{Jednym z takich błędów jest wyciek pamięci powstały w wyniku wykorzystywania niektórych struktur standardowej biblioteki języka (\textsc{C++ STL}), których sposób zarządzania pamięcią powoduje zgłaszanie takich informacji.}, zaś zastosowanie tej flagi pozwala na ich pominięcie. Przykładowe wywołanie skryptu przedstawiono poniżej:

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{text}
|# :\textapprox/git/RIT/RIT\_Library\$ ./memcheck.bash -r ./BinaryIMST\_Library -o out.log -s ./valgrind.supp|
'Valgrind' is required in order to memcheck this application.
Package 'valgrind' is already installed. Skipping...
Running valgrind with additional configuration from file 
'|\textapprox|/git/BinaryIMST/BinaryIMST_Library/valgrind.supp' 
(log file will be generated as 'out.log')...
	[...]
No errors.
\end{minted}

Następnym skryptem wartym omówienia jest \textsf{toggleLogs.bash} - jego uruchomienie skutkuje automatycznym usunięciem zależności od biblioteki \textsc{log4cxx} z wybranego projektu. Należy zwrócić uwagę na fakt możliwego spowolnienia działania aplikacji ze względu na konieczność wypisywania bardzo dużej liczby informacji do wydzielonego pliku, bądź bezpośrednio do wiersza poleceń --- z uwagi na to, że w niektórych przypadkach może nam zależeć na zmaksymalizowaniu efektywności stosowanych algorytmów (bardziej niż na dokładnym informowaniu nas przez aplikację o podjętych przez nią działaniach), mamy możliwość tymczasowego wydzielenia wszystkich elementów wspomnianej biblioteki:

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{text}
|# :\textapprox/git/RIT\$ ./RIT\_Library/toggleLogs.bash |
Create directory '|\textapprox|/git/RIT/RIT_Library/extracted_log/src/include'.
Create directory '|\textapprox|/git/RIT/RIT_Library/extracted_log/src/src'.
--------------------------------------------------------------
Removing logs from project...
Move logging-related sources out from project...
Move '|\textapprox|/git/RIT/RIT_Library/src/src/log' > '|\textapprox|/git/RIT/RIT_Library/extracted_log/src/src'.

Comment logging-related code in source files...

Parsing file: |\textapprox|/git/RIT/RIT_Library/src/src/heap/VertexHeapItem.cpp
	[...]
Parsing file: |\textapprox|/git/RIT/RIT_Library/src/src/bundle/EN_US_Bundle.cpp

All logging-related code in source files has been commended.

Move logging-related headers out from project...
Move '|\textapprox|/git/RIT/RIT_Library/src/include/log' > '|\textapprox|/git/RIT/RIT_Library/extracted_log/src/include'.

Comment logging-related code in header files...

Parsing file: |\textapprox|/git/RIT/RIT_Library/src/include/heap/FibonacciHeap.hpp
	[...]
Parsing file: |\textapprox|/git/RIT/RIT_Library/src/include/typedefs/struct.hpp

All logging-related code in headers files has been commended.
\end{minted}

Uruchomienie skryptu ponownie spowoduje umieszczenie wszystkich usuniętych informacji na powrót w projekcie, którego wywoływany skrypt dotyczy. Bezpośrednio z już omówionych skryptów ( \textsf{toggleLogs.bash}, \textsf{build.bash}, \textsf{memcheck.bash}) korzysta następny z nich: \textsf{fullBuild.bash}, który obsługuje cały proces kompilacji rozwiązania, który jest podzielony na następujące etapy:
\begin{itemize}
	\item usunięcia z projektu zależności od biblioteki \textsc{log4xx} w celu zmaksymalizowania efektywności budowanego rozwiązania,
	\item kompilacji całego projektu,
	\item przeanalizowania wygenerowanej aplikacji pod kątem wycieków pamięci i zapisania wyników do pliku (domyślnie \textsf{valgrind.log}),
	\item przywrócenia do projektu usuniętej wcześniej funkcjonalności.
\end{itemize}

\subsection{Biblioteka: log4cxx}

Proponowane przez nas rozwiązanie w postaci biblioteki RIT zapewnia możliwość zapisywania operacji wykonywanych przez aplikacje ją wykorzystującą. Dla każdego z projektów, w odpowiadających im plikach Log4cxxConfig.xml, znajduje się szczegółowa konfiguracja, determinująca sposób działania opisywanej funkcjonalności, gdzie przykładową konfigurację przedstawiamy poniżej:

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{xml}
<category name="utils.TabuSearchUtils" additivity="false">
	<priority value="warn" />
	<appender-ref ref="appxFileAppender" />
	<appender-ref ref="appxConsoleAppender" />
	<!-- <appender-ref ref="appxXMLAppender" /> -->
	<!-- <appender-ref ref="appxChainsawXMLAppender" /> -->
</category>
\end{minted}

W powyżej prezentowanym przykładzie przedstawiono konfigurację dla pliku \textsf{TabuSearchUtils.cpp}, znajdującego się w katalogu \textsf{./RIT\_Library/src/src/utils/}. Ma ona bezpośredni wpływ na sposób zachowania się wszystkich instrukcji w danym pliku, które powodują wygenerowanie zapisów w dzienniku zdarzeń aplikacji np. \mintinline{cpp}|TRACE(logger, klucz, ...)|. Dla powyżej zaprezentowanego przykładu, wymieniony fragment kodu nie zostałby wykonany --- jego poziom, jaki sobą reprezentuje, jest za niski, w odniesieniu do jego konfiguracji (\textsc{WARN}). W tym przypadku wszystkie akcje z pliku, którego tyczy się przykładowa konfiguracja, przypisane do niższego poziomu niż zadeklarowany w konfiguracji, nie zostaną wykonane ($\textsc{OFF} < \textsc{FATAL} < \textsc{ERROR} < \textsc{WARN} < \textsc{INFO} < \textsc{DEBUG} < \textsc{TRACE} < \textsc{ALL}$). Pozostała część prezentowanej konfiguracji determinuje sposób w jaki dane wyrażenia (wszystkie zapisy dziennika zdarzeń występujących w pliku \textsf{./RIT\_Library/src/src/utils/TabuSearchUtils}) będą przetwarzane. Odpowiednio:

\begin{itemize}
	\item \mintinline{xml}|appxFileAppender| wskazuje, że będą one zapisywane do zewnętrznego pliku (domyślnie \textsf{appxLogFile.log}),
	\item \mintinline{xml}|appxConsoleAppender|  dodatkowo przekierowuje wszystkie informacje do wiersza poleceń, tego samego, w którym została uruchomiona aplikacja,
	\item oznaczone jako nieaktywne wiersze z wartościami \mintinline{xml}|appxXMLAppender| oraz \mintinline{xml}|appxChainsawXMLAppender| zabraniają tym samym przesyłania tych samych danych w jeszcze inne miejsca, gdzie pierwsza z opcji generowałaby na ich podstawie odpowiednio sformatowany plik \textsc{XML}, druga zaś pozwalałaby na przechwytywanie generowanych informacji zewnętrznemu programowi, \textsc{Apache Chainsaw}.
\end{itemize}

Przykłady wygenerowanych dzienników zdarzeń (ich fragmenty) zostaną przytoczone niżej, przy okazji omawiania właściwej funkcjonalności biblioteki \textsc{RIT}.

\subsubsection{Dziennik zdarzeń w Apache Chainsaw}

Korzystanie z zewnętrznej aplikacji w celu polepszenia kultury pracy z zapisami zdarzeń, generowanych przez aplikację, jest bardzo intuicyjne. Aby rozpocząć przechwytywanie wszystkich komunikatów z aplikacji (w celu np. ich swobodnego filtrowania), należy w głównym pliku konfiguracyjnym zadbać o to, by odpowiednie części konfiguracji, te tyczące się interesujących nas elementów, zezwalały na przekierowywanie komunikatów do wspomnianej aplikacji (\mintinline{xml}|<appender-ref ref="appxChainsawXMLAppender" />|) jak i miały odpowiednio ustawiony poziom, który będzie wyższy niż ten, który podany w \textsc{Apache Chainsaw}. Samo korzystanie z owego programu jest bardzo proste i sprowadza się do utworzenia obiektu, który będzie odbierał przekazywane do niego zapisy dziennika zdarzeń (w tym wypadku powinien być to obiekt \mintinline{java}|XMLSocketReceiver|), ustawienie odpowiedniego portu nasłuchiwania (\mintinline{xml}|<param name="Port" value="4448" />|) oraz poziomu szczegółów, jaki nas interesuje. Po tej konfiguracji program powinien być gotowy do pracy.

\subsection{Pozostałe biblioteki i skrypty grafowe}

Poza biblioteką \textsc{log4cxx}, w projekcie znalazły zastosowanie jeszcze dwie: \textsc{gTest} oraz \textsc{GraphViz}, gdzie ta pierwsza z nich pozwala na pisanie automatycznych testów jednostkowych dla zaimplementowanej biblioteki (testy te są częścią aplikacji \textsc{RIT\_Examples} i to ich wynik jest domyślnie zwracany w przypadku poprawnego zakończenia się wykonywanego programu), druga pełni jedynie funkcje pomocnicze --- pozwala konwertować wejściowe formaty grafowe dla programu na inne (o tym więcej w następnej części przy omawianiu formatu danych, jakie obsługuje biblioteka \textsc{RIT\_Library}). Do omówienia pozostały nam jeszcze dwa skrypty, które co prawda nie mają bezpośredniego zastosowania w procesie budowy biblioteki, jednakże są wielce przydatne w trakcie jej użytkowania np. do generowania danych.

\dirtree{%
	.1 /.
	.2 \textsf{Scripts}.
	.3 randDistance.bash.
	.3 randDistance.pl.
}

Skrypt służy do szybkiego, automatycznego generowania danych mających głównie charakter scenariuszy adwersarza dla zadanego już grafu $G$. Podając na jego wejściu odpowiednie parametry, w ciągu bardzo krótkiego czasu otrzymamy w zamian plik z definicjami kosztów tego samego grafu, które w określonym przez nas stopniu różnią się od tych, którymi charakteryzował się oryginalny graf. Poniżej opisujemy wszystkie parametry omawianego skryptu wraz z przykładowym jego wywołaniem\footnote{Do poprawnego działania skrypt wymaga obecności interpretera języka skryptowego \textsc{Perl}.}:

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{text}
|# :\textapprox/git/RIT/Scripts\$ ./randDistance.bash |
-l --lowerBound <arg> - dolna wartość przedziału zaburzeń kosztów w grafie 
			- do każdej krawędzi (do jej kosztu) zostanie dodana wartość 
			z przedziału, którego dolny kres reprezentuje dany parametr,
-u --upperBound <arg> - górna wartość przedziału, gdzie każda waga krawędzi
			zostanie zastąpiona nowym kosztem, określonym za pomocą tej 
			oraz poprzedniej wartości. Do kosztów krawędzi zostanie dodana 
			losowo wybrana (z rozkładem jednostajnym) wartość z przedziału [l; u],
-i --input            - ścieżka do pliku z definicją grafu, zapisana w formacie 
			zdefiniowanym przez 9th DIMACS Implementation Challenge,
-o --output           - ścieżka pliku, do którego będą zapisane nowe koszty dla grafu wejściowego,
-s --seed             - prawdopodobieństwo zmiany kosztu krawędzi. 
			Im wyższe, tym więcej wag krawędzi ulegnie zmianie.
\end{minted}

Aby otrzymać zupełnie losowy rozkład dla wejściowych kosztów grafu, wszystkie w nim koszty powinny mieć wartość równą $C$, zaś parametrami, które określają odpowiednio najmniejszą i największą możliwą wartość dodaną do kosztu krawędzi, powinny być odpowiednio $-C$ oraz $C$, gdzie $seed = 1$. Przy takiej konfiguracji prawdopodobieństwo zmiany kosztów krawędzi w grafie wynosi $1$ (zmianie ulegną wszystkie koszty), zaś każdy z nich zostanie wybrany z przedziału $\left[ C - C, C + C \right]$ (zdecydowaliśmy się ograniczyć koszty do nieujemnych wartości całkowitych).

\dirtree{%
	.1 /.
	.2 \textsf{Scripts}.
	.3 generatePlot.bash.
}

W celu jak największego ułatwienia generowania wykresów danych, które zwracają algorytmy biblioteki \textsc{RIT}, możemy wykorzystać powyższy skrypt. Jego parametry, które przyjmuje, są o tyle nietypowe, że dzielą się na dwie części: te, dotyczące sposobu zachowania się skryptu w sensie globalnym, oraz te, które bezpośrednio odpowiadają za wygląd, kreślonych przez program na podstawie wprowadzonych danych, linii, gdzie te drugie mogą być powtarzane cyklicznie (to znaczy, że ostatnie trzy parametry wywołania stanowią nierozerwalną całość, zaś powielenie ich występowania skutkować będzie naniesieniem na ten sam rysunek wykresów większej liczby funkcji --- w tym wypadku kolejność parametrów obu grup względem siebie oraz drugiej grupy, opisującej wygląd generowanych wykresów, jest istotna).

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{text}
|# :\textapprox/git/RIT/Scripts\$ ./generatePlot.bash |
bash generatePlot.bash <bash flags> [<file name> <octave line style> <function label> [...]]

<bash flags> - podzbiór flag, które przyjmuje skrypt, a które definiują jego sposób zachowania:
 -d --defaults              - jeżeli ta flaga jest obecna w linii wywołania polecenia, 
			      skrypt pominie wszelkie pytania odnośnie tych parametrów,
			      dla których zostałą przewidziana wartość domyślna 
			      (wszystkie poniżej opisane, poza nastepną),
 -f --force-yes              - skrypt do działania wymaga zainstalowania środowiska |\textsc{GNU Octave}|, 
			     toteż w przypadku jego braku zostaniemy poproszeni o zgodę 
			     na jego instalację, chyba że zastosowana będzie opisywana flaga,
 -p --octave-path <arg>      - ścieżka do skryptu |\textsc{GNU Octave}|, odpowiedzialnego 
				za rysowanie wykresów w tymże środowisku  (|\textsc{generatePlot.m}|),
 -i --input-data-path <arg>  - ścieżka do katalogu, w którym umieszczone są pliki z danymi,
 -o --output-data-path <arg> - ścieżka katalogu, do którego będą zapisywane wygenerowane pliki,
 -t --plot-title <arg>       - tytuł wygenerowanego przez skrypt wykresu,
 -x --x-axis-title <arg>     - nazwa osi odciętych na wykresie,
 -y --y-axis-title <arg>     - nazwa osi rzędnych,
 -n --file-output-name <arg> - nazwa samego pliku z wygenerowanym przez skrypt wykresem,
 -e --file-extension <arg>   - rozszerzenie przybierane przez generowany plik (np. |\textsc{eps}|, |\textsc{pdf}|),
 -h --help                   - drukuje skróconą instrukcję sposobu korzystania ze skryptu.

<file name> - nazwa pliku z danymi dla skryptu w określonym formacie. Dane w pliku:
	|$1	\qquad 1$|
	|$2 \qquad	4$|
	|$3 \qquad	9$|
	|$\dots \qquad \dots$|
są przykładem funkcji kwadratowej |$f \left( n \right) = n^{2}$|.

<octave line style> - styl rysowania przez interpreter |\textsc{GNU Octave}| w formacie |\textsc{FMT}| (np. ,,b-'')

<function label> - nazwa konkretnej funkcji na wykresie, odpowiadająca podanym wyżej danym.
\end{minted}

Poniżej przedstawiono strukturę, z której korzysta skrypt \textsc{generatePlot.bash} w przypadku pozostawienia wartości domyślnych jako parametrów (gdy flaga \mintinline{bash}|-d| jest ustawiona, bądź nie zostały wprowadzone inne dane).

\dirtree{%
	.1 /.
	.2 \textsf{Scripts}.
	.3 \textsc{octave}.
	.3 \textsc{plots}.
	.4 \textsc{inData} \ldots{} 
	\begin{minipage}[t]{12cm}
		Domyślny katalog, gdzie skrypt będzie szukał danych wejściowych{.}
	\end{minipage}.
	.4 \textsc{outData} \ldots{} 
	\begin{minipage}[t]{12cm}
		Domyślny katalog, gdzie skrypt będzie zapisywał wygenerowane pliki{.}
	\end{minipage}.
	.3 generatePlot.bash.
	.3 \textcolor{lgray}{randDistance.bash}.
	.3 \textcolor{lgray}{randDistance.perl}.
}

Przykładowe wywołanie takiego skryptu może wyglądać na przykład tak:

\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{text}
|# :\textapprox/git/RIT/Scripts\$ ./generatePlot.bash data1 b- label1 data2 g-- label2 |

---------------------------------------------------------------------------------
Add to dataArray:  data1
Add to styleArray:  b-
Add to legendArray:  label1
Add to dataArray:  data2
Add to styleArray:  g--
Add to legendArray:  label2
Enter path to generatePlot.m Octave function ("./octave" if left blank): 
Enter path to folder with Data Input Files ("./plots/inData" if left blank): 
Enter path to output folder for generated plot ("./plots/outData" if left blank): 
Enter title of generated plot ("{EMPTY TITLE}" if left blank): 
Enter title of label for axis X ("{X LABEL}" if left blank): 
Enter title of label for axis Y ("{Y LABEL}" if left blank): 
Enter name of output file ("out" if left blank): 
Enter extension of output file ("epsc" if left blank): 
Plot configuration summary: 
Octave function path :	|\textapprox|/git/RIT/Scripts/octave/
Input data path      :	|\textapprox|/git/RIT/Scripts/plots/inData/
Output plot path     :	|\textapprox|/git/RIT/Scripts/plots/outData/
Plot's title         :	{EMPTY TITLE}
Plot X label         :	{X LABEL}
Plot Y label         :	{Y LABEL}
Output file          :	out.epsc

Do you want to create this plot? (y/n): [y]
	[...]
Plot has been saved to: "|\textapprox|/git/RIT/Scripts/plots/outData/" as "out.epsc",
\end{minted}
gdzie powyższe wywołanie skryptu spowoduje wygenerowanie pliku z dwoma wykresami funkcji, gdzie pierwszy z nich jest narysowany niebieską linią ciągłą (dla danych z pliku \textsc{data1}), drugi zaś, opisany jako ,,label2'',  przerywaną linią zieloną (patrz Rysunek \ref{fig:genplot}). Aby uzyskać więcej informacji na temat dostępnych sposobów formatowania linii, warto zapoznać się z dokumentacją \textsc{GNU Octave}.

\begin{figure}[!htbp]
	\null\hfill
	\includegraphics[width=0.67\textwidth]{Appendix_I/GENERATE-PLOT-example/1}
	\hfill\null
	\caption{
		Wygenerowany wykres dwóch funkcji dla przykładowego wywołania skryptu \textsc{generatePlot.bash}, obrazujący sposób zachowania się algorytmu \textsc{Tabu Search} dla przykładowej instancji grafu $G = \left( V, E \right)$, gdzie $\left| V \right| = 30$ ($G$ jest grafem pełnym), dla okresu szukania rozwiązania równego $50$ (po którym następuje ,,restart'' algorytmu).
	}
	\label{fig:genplot}
\end{figure}

\section{Możliwości biblioteki}

Tak jak wspomnieliśmy na samym początku tego rozdziału, biblioteka \textsc{RIT} implementuje wiele z, dotąd przez nas poznanych, algorytmów. Aby zaprezentować możliwość ich wykorzystania, przedstawimy kilka przypadków działania aplikacji, gdzie każdym z nich będziemy starali odpowiedzieć się na jedno z podstawowych pytań, jakie mogą się nasunąć podczas zapoznawania się ze strukturą wspomnianej biblioteki. Należy mieć na uwadze, że prezentowane w tej części wycinki kodu źródłowego w charakterze odpowiedzi na każde z zadanych przez nas pytań, nie są odpowiedziami jedynymi słusznymi --- większość obiektów, jakie będziemy prezentować, biblioteka \textsc{RIT} pozwala stworzyć na więcej niż jeden sposób. My zaś będziemy starali się prezentować tylko te przypadki użycia, które naszym zdaniem pojawiać się mogą najczęściej przy korzystaniu z niej.

\subsection{Budowanie grafu}

Podstawową czynnością jaką musimy mieć możliwość wykonać, jest budowa grafu, na którym będziemy mogli operować. 

\subsubsection{W jaki sposób zbudować graf przy wykorzystaniu udostępnionych funkcji?}

Biblioteka \textsc{RIT} zapewnia kilka sposobów na generowanie grafów, dla których będziemy później chcieli wykonywać obliczenia. Główne z nich to:
\begin{itemize}
	\item odczytanie definicji całego grafu z pliku --- główne z obsługiwanych formatów opiszemy poniżej, na tę chwilę jesteśmy zainteresowani tylko sposobem wywołania danej funkcjonalności\footnote{W prezentowanych przypadkach użycia pomijamy obsługę wyjątków, zgłaszanych w czasie wykonywania programu, przykładowo prezentując sposób ich przechwytywania tylko w pierwszym z nich.}:
	
	\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{c++}
#include <IMST/exp/IOExceptions.hpp>
#include <IMST/utils/enums/InputFormat.hpp>
#include <IMST/utils/enums/InputMode.hpp>
#include <IMST/utils/IOUtils.hpp>
#include <IMST/utils/MemoryUtils.hpp>

int main() {
	GraphIF* g { };
	try {
		g = InputUtils::readGraph("ścieżka do pliku *.gr", InputFormat::GR, InputMode::HDD);
		MemoryUtils::removeGraph(g, true, true);
	} catch (IOExceptions::FileNotFountException& e) {
		return 0;
	}
	return 0;
}
	\end{minted}
	
	gdzie wartość enumerowana \mintinline{C++}|InputFormat| odpowiada za format, który zdecydowaliśmy się wczytać do programu, \mintinline{C++}|InputMode| --- za sposób jego załadowania, gdzie \mintinline{C++}|HDD| odpowiada standardowej metodzie odczytu pliku, której będziemy używać. Należy oczywiście pamiętać o usunięciu przed chwilą stworzonego grafu najwcześniej jak to tylko możliwe, jeżeli chcemy ustrzec się przed późniejszymi problemami związanymi z zarządzaniem pamięcią przez program (każdy prezentowany przykład będzie zawierać również kod usuwający stworzone przez siebie obiekty).
	
	\item dynamiczna konstrukcja grafu --- umożliwia stworzenie dowolnej struktury grafowej przy wykorzystaniu metod udostępnianych przez bibliotekę. Poniżej widoczny przykład przedstawia sposób stworzenia grafu z trzema wierzchołkami, gdzie każdy z nich jest połączony z pozostałymi (graf pełny). Dla danej klasy \mintinline{C++}|GraphIF|, podobnie jak dla zdecydowanej większości obiektów, które będziemy wykorzystywać w prezentowanych kodach, jest dostępna większa liczba konstruktorów --- sposób generowania grafu dla każdego z nich różni się od poniższego. W tym konkretnym przypadku graf jest budowany na podstawie dwóch zbiorów danych: jego wierzchołków $V$ oraz, łączących je, krawędzi $E$. Poniżej prezentowany sposób konstrukcji grafu $G = \left( V, E \right)$ jest zatem naturalny:
	
	\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{c++}
VertexSetIF* vSet = new VertexSetImpl { 3 };
EdgeSetIF* eSet = new EdgeSetImpl { 3 };
GraphIF* g = new GraphImpl { vSet, eSet };

for (unsigned int idx = 0; idx < 3; idx += 1) {
	vSet->push_back(new VertexImpl { idx });
}

for (unsigned int idx = 0; idx < 3; idx += 1) {
	eSet->push_back(
		new EdgeImpl { idx, VertexPair(vSet->getElementAt(idx),
			vSet->getElementAt((idx + 1) % 3)), (EdgeCost) idx });
}
MemoryUtils::removeGraph(g, true, true);
	\end{minted}
	gdzie kolejno stworzyliśmy trzy wierzchołki grafu, później zaś, z wykorzystaniem operacji wyznaczania reszty z dzielenia,  jego krawędzie: $e_{01}$, $e_{12}$ oraz $e_{20}$, każda o koszcie \mintinline{C++}|idx|.\\
	
	\item losowe generowanie struktury --- udostępnione przez klasę pomocniczą \mintinline{C++}|GraphUtils| funkcje, umożliwiają między innymi wygenerowanie losowego grafu na podstawie takich danych jak:
	\begin{itemize}
		\item liczba wierzchołków docelowego grafu,
		\item liczba krawędzi / gęstość grafu (jeden z dwóch),
		\item najniższy możliwy koszt łuku,
		\item największa waga jaką może przyjąć krawędź.
	\end{itemize}

	\begin{minted}[escapeinside=||,mathescape=true,linenos=true,fontsize=\footnotesize]{c++}
GraphIF* g = GraphUtils::getRandomGraph(10,0.5,10,15);
MemoryUtils::removeGraph(g, true, true);
	\end{minted}
	gdzie parametrami w tym przypadku są: liczba krawędzi oraz gęstość grafu. Powyższy fragment kodu został wykorzystany do wygenerowania wszystkich instancji grafów, dla których zostały przeprowadzone eksperymenty w rozdziale \ref{ch:exp}.
	
\end{itemize}




\subsubsection{Jakie formaty wejściowe obsługuje biblioteka?}

\subsection{Eksport i wizualizacja rozwiązań}

\subsubsection{Jak zapisać wygenerowany graf?}

\subsubsection{Jak stworzyć dwuwymiarowy model grafu?}

\subsection{Rozwiązywanie problemów grafowych}

\subsubsection{MST?}


Uruchomienie procesu poszukiwania minimalnego drzewa rozpinajacego dla grafu G wymaga od nas wpierw stworzenia instacji solvera, którym będziemy dane zagadnienie rozwiązywać:


gdzie obiekty takie jak są definiowane przed odpowiednie im instrukcje preprocesora w plikach nagłówkowych --- taka modularna budowa biblioteki RIT umożliwia szybką zmianę implementacji praktycznie dowolnej struktury, która jest wykorzystywana w aplikacji, bez potrzeby jej przebudowywania (w takiej sytuacji od użytkownika wymaga się jedynie podmiany odpowiedniego pliku nagłówkowego, który został przez niego zmieniony). 

\subsubsection{ILOG CPLEX?}

\subsubsection{IMST?}

\subsubsection{ILOG CPLEX?}

\subsubsection{AIMST?}

\subsubsection{RRIMST?}


% OS path %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \textsf{/Scripts/compileProject.bash}

% Shortcut %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \texttt{CRTL + ALT + T}

% Nazwy własne, argumenty %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textsc{R\_USATest\_DKA}

% ANG %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
(ang. \textit{Directed acyclic graph})

% Figura %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[!htbp]
	\null\hfill
	%\includegraphics[width=0.8\textwidth]{Appendix_I/GENERATE-PLOT-bash/a_psfrag.pdf}
	\hfill\null
	\caption{
		Wygenerowany wykres dwóch funkcji dla przykładowego wywołania skryptu \textsc{generatePlot.bash}.
	}
\end{figure}

% Figury %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[!htbp]
	\null\hfill
	\begin{subfigure}[b]{0.49\textwidth}
		\footnotesize
		\begin{lstlisting}[language=bash]
digraph G {
	rankdir=LR;
	node [shape = circle];
	1 -> 2 [ label = "2"];
	1 -> 3 [ label = "6"];
	2 -> 3 [ label = "3"];
	2 -> 4 [ label = "4"];
	2 -> 5 [ label = "5"];
	3 -> 5 [ label = "1"];
	5 -> 4 [ label = "2"];
}
		\end{lstlisting}
		\caption{}
		\label{fig:graphViz:a}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.49\textwidth}
		%\includegraphics[width=\textwidth]{Appendix_I/GRAPH-VIZ-Example/a.pdf}
		\vspace{1em}
		\caption{}
		\label{fig:graphViz:b}
	\end{subfigure}
	\hfill\null
	\caption{
		Wygenerowana ilustracja grafu przez skrypt \textsc{makeGraphViz.bash}.
		\textbf{(a)}~Kod pośredni pomiędzy danymi wejściowymi w standardowym formacie \textsc{DIMACS Implementation Challenge} a finalnym rysunkiem. Kod pośredni jest zapisany w języku \textsc{DOT}.
		\textbf{(b)}~Rysunek grafu wygenerowany przez program \textsc{GraphViz}.
	}
	\label{fig:graphViz}
\end{figure}

% URL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\url{http://algs4.cs.princeton.edu/home/} na licencji \textsc{GNU GPLv3}

% ALIGN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\begin{align*}
		f(x) +    g(x)  &=          \cos(x) +              \sin(x)             + h(x) \\
		\phantom{f(x) +{}} g(x)  &= \phantom{\cos(x) +{}}          {\sin(x)} \phantom{{}+ h(x)}\\
		f(x)  \phantom{{}+ g(x)} &=          \cos(x) \phantom{{} +  \sin(x)}            + h(x) \\
		s(x)  \phantom{{}+ g(x)} &= \phantom{\cos(x) +{}} \makebox[\widthof{$\sin(x) + h(x)$}][c]{$\arcsin(x)$}
	\end{align*}